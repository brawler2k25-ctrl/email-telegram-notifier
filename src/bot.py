import logging
import asyncio
import json
from typing import Optional, List
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup, Bot
from telegram.ext import Application, CommandHandler, CallbackQueryHandler, ContextTypes
from telegram.error import TelegramError
from queue import Queue
import threading

from config import Settings
from db import EmailDatabase
from parser import EmailParser

logger = logging.getLogger(__name__)

class TelegramBot:
    def __init__(
        self,
        settings: Settings,
        database: EmailDatabase,
        email_queue: Queue
    ):
        self.settings = settings
        self.database = database
        self.email_queue = email_queue
        self.parser = EmailParser(
            max_preview_length=settings.max_preview_length,
            spam_keywords=settings.spam_keywords
        )
        self.application: Optional[Application] = None
        self.bot: Optional[Bot] = None
        self.running = False
        self.process_thread: Optional[threading.Thread] = None
    
    async def start_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle /start command"""
        if not update.effective_chat.type in ['group', 'supergroup']:
            await update.message.reply_text("–≠—Ç–æ—Ç –±–æ—Ç —Ä–∞–±–æ—Ç–∞–µ—Ç —Ç–æ–ª—å–∫–æ –≤ –≥—Ä—É–ø–ø–∞—Ö!")
            return
        
        group_info = self.database.get_group_by_chat_id(update.effective_chat.id)
        if group_info:
            stats = self.database.get_group_stats(update.effective_chat.id)
            message = (
                f"üëã –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ Email Notifier Bot!\n\n"
                f"üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –≥—Ä—É–ø–ø—ã:\n"
                f"‚Ä¢ –í—Å–µ–≥–æ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π: {stats.get('total_notifications', 0)}\n"
                f"‚Ä¢ –û–±—Ä–∞–±–æ—Ç–∞–Ω–æ: {stats.get('handled', 0)}\n"
                f"‚Ä¢ –û–∂–∏–¥–∞–µ—Ç: {stats.get('unhandled', 0)}\n\n"
                f"–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–æ–º–∞–Ω–¥—ã:\n"
                f"/subscribe - –ü–æ–¥–ø–∏—Å–∞—Ç—å—Å—è –Ω–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è\n"
                f"/unsubscribe - –û—Ç–ø–∏—Å–∞—Ç—å—Å—è\n"
                f"/filter –æ—Ç–¥–µ–ª1,–æ—Ç–¥–µ–ª2 - –§–∏–ª—å—Ç—Ä –ø–æ –æ—Ç–¥–µ–ª–∞–º\n"
                f"/status - –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞"
            )
        else:
            message = (
                "üëã –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ Email Notifier Bot!\n\n"
                "–≠—Ç–∞ –≥—Ä—É–ø–ø–∞ –Ω–µ –ø–æ–¥–ø–∏—Å–∞–Ω–∞ –Ω–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è.\n"
                "–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /subscribe –¥–ª—è –ø–æ–¥–ø–∏—Å–∫–∏."
            )
        
        await update.message.reply_text(message)
    
    async def subscribe_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle /subscribe command"""
        if not update.effective_chat.type in ['group', 'supergroup']:
            await update.message.reply_text("–≠—Ç–æ—Ç –±–æ—Ç —Ä–∞–±–æ—Ç–∞–µ—Ç —Ç–æ–ª—å–∫–æ –≤ –≥—Ä—É–ø–ø–∞—Ö!")
            return
        
        chat_id = update.effective_chat.id
        chat_title = update.effective_chat.title or "Unknown Group"
        user_id = update.effective_user.id
        
        # Add or update group
        group_id = self.database.add_group(chat_id, chat_title, user_id)
        
        if group_id:
            message = (
                f"‚úÖ –ì—Ä—É–ø–ø–∞ '{chat_title}' –ø–æ–¥–ø–∏—Å–∞–Ω–∞ –Ω–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è!\n\n"
                f"–¢–µ–ø–µ—Ä—å –≤—ã –±—É–¥–µ—Ç–µ –ø–æ–ª—É—á–∞—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ—Ç –≤—Å–µ—Ö email –∞–∫–∫–∞—É–Ω—Ç–æ–≤.\n"
                f"–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /filter –¥–ª—è –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ —Ñ–∏–ª—å—Ç—Ä–æ–≤ –ø–æ –æ—Ç–¥–µ–ª–∞–º."
            )
        else:
            message = "‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–¥–ø–∏—Å–∫–µ –≥—Ä—É–ø–ø—ã."
        
        await update.message.reply_text(message)
    
    async def unsubscribe_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle /unsubscribe command"""
        if not update.effective_chat.type in ['group', 'supergroup']:
            await update.message.reply_text("–≠—Ç–æ—Ç –±–æ—Ç —Ä–∞–±–æ—Ç–∞–µ—Ç —Ç–æ–ª—å–∫–æ –≤ –≥—Ä—É–ø–ø–∞—Ö!")
            return
        
        chat_id = update.effective_chat.id
        
        if self.database.remove_group(chat_id):
            message = "‚úÖ –ì—Ä—É–ø–ø–∞ –æ—Ç–ø–∏—Å–∞–Ω–∞ –æ—Ç —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π."
        else:
            message = "‚ùå –ì—Ä—É–ø–ø–∞ –Ω–µ –±—ã–ª–∞ –ø–æ–¥–ø–∏—Å–∞–Ω–∞."
        
        await update.message.reply_text(message)
    
    async def filter_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle /filter command"""
        if not update.effective_chat.type in ['group', 'supergroup']:
            await update.message.reply_text("–≠—Ç–æ—Ç –±–æ—Ç —Ä–∞–±–æ—Ç–∞–µ—Ç —Ç–æ–ª—å–∫–æ –≤ –≥—Ä—É–ø–ø–∞—Ö!")
            return
        
        chat_id = update.effective_chat.id
        
        # Check if group is subscribed
        group_info = self.database.get_group_by_chat_id(chat_id)
        if not group_info:
            await update.message.reply_text("‚ùå –ì—Ä—É–ø–ø–∞ –Ω–µ –ø–æ–¥–ø–∏—Å–∞–Ω–∞. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /subscribe")
            return
        
        # Parse filter arguments
        if context.args:
            filter_text = " ".join(context.args)
            if filter_text.lower() == "clear":
                # Clear filter
                self.database.update_group_filter(chat_id, None)
                await update.message.reply_text("‚úÖ –§–∏–ª—å—Ç—Ä –æ—á–∏—â–µ–Ω. –¢–µ–ø–µ—Ä—å –ø–æ–ª—É—á–∞–µ—Ç–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ—Ç –≤—Å–µ—Ö –æ—Ç–¥–µ–ª–æ–≤.")
                return
            
            # Set filter
            filters = [f.strip() for f in filter_text.split(",")]
            self.database.update_group_filter(chat_id, filters)
            
            filter_list = ", ".join(filters)
            message = f"‚úÖ –£—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω —Ñ–∏–ª—å—Ç—Ä: {filter_list}\n\n–¢–µ–ø–µ—Ä—å –ø–æ–ª—É—á–∞–µ—Ç–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è —Ç–æ–ª—å–∫–æ –æ—Ç —ç—Ç–∏—Ö –æ—Ç–¥–µ–ª–æ–≤."
        else:
            # Show current filter
            current_filter = group_info.get('filter_accounts')
            if current_filter:
                filter_accounts = json.loads(current_filter)
                filter_list = ", ".join(filter_accounts)
                message = f"üîç –¢–µ–∫—É—â–∏–π —Ñ–∏–ª—å—Ç—Ä: {filter_list}\n\n"
            else:
                message = "üîç –§–∏–ª—å—Ç—Ä –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω (–ø–æ–ª—É—á–∞–µ—Ç–µ –æ—Ç –≤—Å–µ—Ö –æ—Ç–¥–µ–ª–æ–≤)\n\n"
            
            message += (
                "–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ:\n"
                "/filter –æ—Ç–¥–µ–ª1,–æ—Ç–¥–µ–ª2 - —É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å —Ñ–∏–ª—å—Ç—Ä\n"
                "/filter clear - –æ—á–∏—Å—Ç–∏—Ç—å —Ñ–∏–ª—å—Ç—Ä"
            )
        
        await update.message.reply_text(message)
    
    async def status_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle /status command"""
        if not update.effective_chat.type in ['group', 'supergroup']:
            await update.message.reply_text("–≠—Ç–æ—Ç –±–æ—Ç —Ä–∞–±–æ—Ç–∞–µ—Ç —Ç–æ–ª—å–∫–æ –≤ –≥—Ä—É–ø–ø–∞—Ö!")
            return
        
        chat_id = update.effective_chat.id
        group_info = self.database.get_group_by_chat_id(chat_id)
        
        if not group_info:
            await update.message.reply_text("‚ùå –ì—Ä—É–ø–ø–∞ –Ω–µ –ø–æ–¥–ø–∏—Å–∞–Ω–∞. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /subscribe")
            return
        
        stats = self.database.get_group_stats(chat_id)
        overall_stats = self.database.get_overall_stats()
        
        # Get filter info
        current_filter = group_info.get('filter_accounts')
        if current_filter:
            filter_accounts = json.loads(current_filter)
            filter_text = f"üîç –§–∏–ª—å—Ç—Ä: {', '.join(filter_accounts)}"
        else:
            filter_text = "üîç –§–∏–ª—å—Ç—Ä: –í—Å–µ –æ—Ç–¥–µ–ª—ã"
        
        message = (
            f"üìä *–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –≥—Ä—É–ø–ø—ã*\n\n"
            f"üì¨ –ì—Ä—É–ø–ø–∞: {group_info['chat_title']}\n"
            f"{filter_text}\n\n"
            f"*–£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –≤ —ç—Ç–æ–π –≥—Ä—É–ø–ø–µ:*\n"
            f"‚Ä¢ –í—Å–µ–≥–æ: {stats.get('total_notifications', 0)}\n"
            f"‚Ä¢ –û–±—Ä–∞–±–æ—Ç–∞–Ω–æ: {stats.get('handled', 0)}\n"
            f"‚Ä¢ –û–∂–∏–¥–∞–µ—Ç: {stats.get('unhandled', 0)}\n\n"
            f"*–û–±—â–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –±–æ—Ç–∞:*\n"
            f"‚Ä¢ Email –∞–∫–∫–∞—É–Ω—Ç–æ–≤: {len(self.settings.email_accounts)}\n"
            f"‚Ä¢ –ê–∫—Ç–∏–≤–Ω—ã—Ö –≥—Ä—É–ø–ø: {overall_stats.get('active_groups', 0)}\n"
            f"‚Ä¢ –í—Å–µ–≥–æ –ø–∏—Å–µ–º: {overall_stats.get('total_emails', 0)}"
        )
        
        await update.message.reply_text(message, parse_mode='Markdown')
    
    async def help_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle /help command"""
        message = (
            "ü§ñ *Email Notifier Bot*\n\n"
            "*–ö–æ–º–∞–Ω–¥—ã –¥–ª—è –≥—Ä—É–ø–ø:*\n"
            "/subscribe - –ü–æ–¥–ø–∏—Å–∞—Ç—å –≥—Ä—É–ø–ø—É –Ω–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è\n"
            "/unsubscribe - –û—Ç–ø–∏—Å–∞—Ç—å –≥—Ä—É–ø–ø—É\n"
            "/filter –æ—Ç–¥–µ–ª1,–æ—Ç–¥–µ–ª2 - –ù–∞—Å—Ç—Ä–æ–∏—Ç—å —Ñ–∏–ª—å—Ç—Ä –ø–æ –æ—Ç–¥–µ–ª–∞–º\n"
            "/filter clear - –û—á–∏—Å—Ç–∏—Ç—å —Ñ–∏–ª—å—Ç—Ä\n"
            "/status - –ü–æ–∫–∞–∑–∞—Ç—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É\n"
            "/help - –ü–æ–∫–∞–∑–∞—Ç—å —ç—Ç—É —Å–ø—Ä–∞–≤–∫—É\n\n"
            "*–ö–∞–∫ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å:*\n"
            "1. –î–æ–±–∞–≤—å—Ç–µ –±–æ—Ç–∞ –≤ –≥—Ä—É–ø–ø—É –∫–∞–∫ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞\n"
            "2. –û—Ç–ø—Ä–∞–≤—å—Ç–µ /subscribe –¥–ª—è –ø–æ–¥–ø–∏—Å–∫–∏\n"
            "3. –ù–∞—Å—Ç—Ä–æ–π—Ç–µ —Ñ–∏–ª—å—Ç—Ä—ã –ø—Ä–∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏\n"
            "4. –ù–∞–∂–∏–º–∞–π—Ç–µ 'Read ‚úÖ' –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –ø–∏—Å–µ–º"
        )
        
        await update.message.reply_text(message, parse_mode='Markdown')
    
    async def handle_read_button(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle the Read button callback"""
        query = update.callback_query
        
        if query.data.startswith("read_"):
            telegram_message_id = query.message.message_id
            user_id = query.from_user.id
            
            # Mark as handled in database
            if self.database.mark_notification_handled(telegram_message_id, user_id):
                # Delete the message for everyone
                try:
                    await query.message.delete()
                    await query.answer("‚úÖ –ü–∏—Å—å–º–æ –ø–æ–º–µ—á–µ–Ω–æ –∫–∞–∫ –ø—Ä–æ—á–∏—Ç–∞–Ω–Ω–æ–µ", show_alert=False)
                    
                    logger.info(f"Email notification handled by user {user_id}")
                except TelegramError as e:
                    logger.error(f"Error deleting message: {e}")
                    await query.answer("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ —Å–æ–æ–±—â–µ–Ω–∏—è", show_alert=True)
            else:
                await query.answer("‚ö†Ô∏è –ü–∏—Å—å–º–æ —É–∂–µ –æ–±—Ä–∞–±–æ—Ç–∞–Ω–æ", show_alert=True)
    
    async def send_email_notification(self, email_data: dict, group_id: int, chat_id: int) -> Optional[int]:
        """Send email notification to specific group"""
        try:
            # Format the message
            message = self.parser.format_telegram_message(
                account_label=email_data['account_label'],
                account_email=email_data['account_email'],
                sender=email_data['sender'],
                subject=email_data['subject'],
                body_preview=email_data['body_preview']
            )
            
            # Create inline keyboard with Read button
            keyboard = [[InlineKeyboardButton("Read ‚úÖ", callback_data=f"read_{email_data['email_id']}")]]
            reply_markup = InlineKeyboardMarkup(keyboard)
            
            # Send message
            sent_message = await self.bot.send_message(
                chat_id=chat_id,
                text=message,
                parse_mode='MarkdownV2',
                reply_markup=reply_markup
            )
            
            # Save notification to database
            self.database.add_notification(email_data['email_id'], group_id, sent_message.message_id)
            
            return sent_message.message_id
            
        except Exception as e:
            logger.error(f"Error sending Telegram notification to group {chat_id}: {e}")
            return None
    
    def should_send_to_group(self, group_info: dict, email_account_label: str) -> bool:
        """Check if email should be sent to specific group based on filters"""
        filter_accounts = group_info.get('filter_accounts')
        if not filter_accounts:
            return True  # No filter, send all
        
        try:
            filters = json.loads(filter_accounts)
            return email_account_label in filters
        except:
            return True  # Error in filter, send all
    
    def process_email_queue(self):
        """Process emails from the queue"""
        logger.info("Starting email queue processor")
        
        while self.running:
            try:
                # Get email from queue (with timeout to check running flag)
                email_data = self.email_queue.get(timeout=1)
                
                # Parse the email
                parsed = self.parser.parse_email(email_data['raw_email'])
                
                if not parsed:
                    logger.warning("Failed to parse email")
                    continue
                
                # Check if it's spam
                if parsed['is_spam']:
                    logger.info(f"Skipping spam/auto-reply email: {parsed['subject']}")
                    continue
                
                # Check if email already exists
                if self.database.email_exists(
                    parsed['message_id'],
                    parsed['sender'],
                    parsed['subject']
                ):
                    logger.info(f"Email already exists: {parsed['subject']}")
                    continue
                
                # Add to database
                email_id = self.database.add_email(
                    message_id=parsed['message_id'],
                    email_account=f"{email_data['account_label']} ({email_data['account_email']})",
                    sender=parsed['sender'],
                    subject=parsed['subject'],
                    body_preview=parsed['body_preview'],
                    received_date=parsed['received_date']
                )
                
                if email_id:
                    # Get all active groups
                    active_groups = self.database.get_active_groups()
                    
                    for group in active_groups:
                        # Check if email should be sent to this group
                        if self.should_send_to_group(group, email_data['account_label']):
                            # Check if already sent to this group
                            if not self.database.email_sent_to_group(email_id, group['id']):
                                # Prepare notification data
                                notification_data = {
                                    'email_id': email_id,
                                    'account_label': email_data['account_label'],
                                    'account_email': email_data['account_email'],
                                    'sender': parsed['sender'],
                                    'subject': parsed['subject'],
                                    'body_preview': parsed['body_preview']
                                }
                                
                                # Send notification (run in event loop)
                                loop = asyncio.new_event_loop()
                                asyncio.set_event_loop(loop)
                                
                                telegram_message_id = loop.run_until_complete(
                                    self.send_email_notification(
                                        notification_data, 
                                        group['id'], 
                                        group['chat_id']
                                    )
                                )
                                
                                loop.close()
                                
                                if telegram_message_id:
                                    logger.info(f"Sent notification to group {group['chat_title']}: {parsed['subject']}")
                
            except Exception as e:
                if self.running:  # Only log if not shutting down
                    logger.error(f"Error processing email queue: {e}")
        
        logger.info("Email queue processor stopped")
    
    async def initialize(self):
        """Initialize the bot"""
        # Create application
        self.application = Application.builder().token(self.settings.telegram_bot_token).build()
        self.bot = self.application.bot
        
        # Add handlers
        self.application.add_handler(CommandHandler("start", self.start_command))
        self.application.add_handler(CommandHandler("subscribe", self.subscribe_command))
        self.application.add_handler(CommandHandler("unsubscribe", self.unsubscribe_command))
        self.application.add_handler(CommandHandler("filter", self.filter_command))
        self.application.add_handler(CommandHandler("status", self.status_command))
        self.application.add_handler(CommandHandler("help", self.help_command))
        self.application.add_handler(CallbackQueryHandler(self.handle_read_button))
        
        # Initialize application
        await self.application.initialize()
        await self.application.start()
        
        logger.info("Telegram bot initialized")
    
    async def start(self):
        """Start the bot"""
        self.running = True
        
        # Start email queue processor in separate thread
        self.process_thread = threading.Thread(target=self.process_email_queue)
        self.process_thread.daemon = True
        self.process_thread.start()
        
        # Start polling
        await self.application.updater.start_polling()
        
        logger.info("Telegram bot started")
    
    async def stop(self):
        """Stop the bot"""
        logger.info("Stopping Telegram bot")
        
        self.running = False
        
        # Stop the processor thread
        if self.process_thread:
            self.process_thread.join(timeout=5)
        
        # Stop the application
        if self.application:
            await self.application.updater.stop()
            await self.application.stop()
            await self.application.shutdown()
        
        logger.info("Telegram bot stopped")
    
    async def run(self):
        """Run the bot (blocking)"""
        await self.initialize()
        await self.start()
        
        # Keep running until interrupted
        try:
            await asyncio.Event().wait()
        except KeyboardInterrupt:
            pass
        finally:
            await self.stop()